/// <reference types="node" />
import { PromisyClass } from './Task';
export declare class TaskQueue<PromiseType extends PromisyClass> {
    private Promise;
    /** Number of promises allowed to resolve concurrently. */
    concurrency: number;
    constructor(Promise: PromiseType, 
    /** Number of promises allowed to resolve concurrently. */
    concurrency: number);
    /** Add a new task to the queue.
      * It will start when the number of other concurrent tasks is low enough.
      * @param func Function to call.
      * @param delay Initial delay in milliseconds before making the call. */
    add(func: () => any, delay?: number): PromiseLike<any>;
    /** Consider current function idle until promise resolves.
      * Useful for making recursive calls. */
    unblock<Result>(promise: PromiseLike<Result>): PromiseLike<Result>;
    /** Wrap a function returning a promise, so that before running
      * it waits until concurrent invocations are below this queue's limit. */
    wrap<Result>(func: () => Result | PromiseLike<Result>, thisObject?: any): () => PromiseLike<Result>;
    wrap<Result, A>(func: (a: A) => Result | PromiseLike<Result>, thisObject?: any): (a: A) => PromiseLike<Result>;
    wrap<Result, A, B>(func: (a: A, b: B) => Result | PromiseLike<Result>, thisObject?: any): (a: A, b: B) => PromiseLike<Result>;
    wrap<Result, A, B, C>(func: (a: A, b: B, c: C) => Result | PromiseLike<Result>, thisObject?: any): (a: A, b: B, c: C) => PromiseLike<Result>;
    wrap<Result, A, B, C, D>(func: (a: A, b: B, c: C, d: D) => Result | PromiseLike<Result>, thisObject?: any): (a: A, b: B, c: C, d: D) => PromiseLike<Result>;
    /** Start the next task from the backlog. */
    private next;
    private nextBound;
    private nextTickBound;
    private busyCount;
    private backlog;
    timer: number | NodeJS.Timer;
    timerStamp: number;
}
