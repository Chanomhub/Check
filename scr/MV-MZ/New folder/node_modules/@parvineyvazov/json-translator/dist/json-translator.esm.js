import { translate as translate$2 } from '@vitalets/google-translate-api';
import { translate as translate$1 } from 'bing-translate-api';
import createHttpProxyAgent from 'http-proxy-agent';
import axios from 'axios';
import translate2 from '@iamtraction/google-translate';
import { readFile, writeFile } from 'fs/promises';
import { parse, stringify } from 'yaml';
import { TaskQueue } from 'cwait';
import { Promise as Promise$1 } from 'bluebird';
import loading from 'loading-cli';
import { promises } from 'fs';
import { Option, Command } from 'commander';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

var version = "2.2.2";

function translationStatistic(totalTranslated, totalTranslation) {
  return totalTranslated + " of " + totalTranslation + " translated.";
}
var current_version = version;
var default_value = '--';
var translation_value_limit = 5000;
var default_concurrency_limit = 3;
var fallbacks = {
  yes: true,
  no: false
};
var default_fallback = fallbacks.no;

var GoogleTranslateLanguages = {
  Automatic: 'auto',
  Afrikaans: 'af',
  Albanian: 'sq',
  Amharic: 'am',
  Arabic: 'ar',
  Armenian: 'hy',
  Azerbaijani: 'az',
  Basque: 'eu',
  Belarusian: 'be',
  Bengali: 'bn',
  Bosnian: 'bs',
  Bulgarian: 'bg',
  Catalan: 'ca',
  Cebuano: 'ceb',
  Chichewa: 'ny',
  Chinese_Simplified: 'zh-CN',
  Chinese_Traditional: 'zh-TW',
  Corsican: 'co',
  Croatian: 'hr',
  Czech: 'cs',
  Danish: 'da',
  Dutch: 'nl',
  English: 'en',
  Esperanto: 'eo',
  Estonian: 'et',
  Filipino: 'tl',
  Finnish: 'fi',
  French: 'fr',
  Frisian: 'fy',
  Galician: 'gl',
  Georgian: 'ka',
  German: 'de',
  Greek: 'el',
  Gujarati: 'gu',
  Haitian_Creole: 'ht',
  Hausa: 'ha',
  Hawaiian: 'haw',
  Hebrew: 'iw',
  Hindi: 'hi',
  Hmong: 'hmn',
  Hungarian: 'hu',
  Icelandic: 'is',
  Igbo: 'ig',
  Indonesian: 'id',
  Irish: 'ga',
  Italian: 'it',
  Japanese: 'ja',
  Javanese: 'jw',
  Kannada: 'kn',
  Kazakh: 'kk',
  Khmer: 'km',
  Korean: 'ko',
  Kurdish_Kurmanji: 'ku',
  Kyrgyz: 'ky',
  Lao: 'lo',
  Latin: 'la',
  Latvian: 'lv',
  Lithuanian: 'lt',
  Luxembourgish: 'lb',
  Macedonian: 'mk',
  Malagasy: 'mg',
  Malay: 'ms',
  Malayalam: 'ml',
  Maltese: 'mt',
  Maori: 'mi',
  Marathi: 'mr',
  Mongolian: 'mn',
  Myanmar_Burmese: 'my',
  Nepali: 'ne',
  Norwegian: 'no',
  Pashto: 'ps',
  Persian: 'fa',
  Polish: 'pl',
  Portuguese: 'pt',
  Punjabi: 'pa',
  Romanian: 'ro',
  Russian: 'ru',
  Samoan: 'sm',
  Scots_Gaelic: 'gd',
  Serbian: 'sr',
  Sesotho: 'st',
  Shona: 'sn',
  Sindhi: 'sd',
  Sinhala: 'si',
  Slovak: 'sk',
  Slovenian: 'sl',
  Somali: 'so',
  Spanish: 'es',
  Sundanese: 'su',
  Swahili: 'sw',
  Swedish: 'sv',
  Tajik: 'tg',
  Tamil: 'ta',
  Telugu: 'te',
  Thai: 'th',
  Turkish: 'tr',
  Ukrainian: 'uk',
  Urdu: 'ur',
  Uzbek: 'uz',
  Vietnamese: 'vi',
  Welsh: 'cy',
  Xhosa: 'xh',
  Yiddish: 'yi',
  Yoruba: 'yo',
  Zulu: 'zu'
};
var GoogleTranslate2Languages = {
  Automatic: 'auto',
  Afrikaans: 'af',
  Albanian: 'sq',
  Amharic: 'am',
  Arabic: 'ar',
  Armenian: 'hy',
  Azerbaijani: 'az',
  Basque: 'eu',
  Belarusian: 'be',
  Bengali: 'bn',
  Bosnian: 'bs',
  Bulgarian: 'bg',
  Catalan: 'ca',
  Cebuano: 'ceb',
  Chichewa: 'ny',
  Chinese_Simplified: 'zh-CN',
  Chinese_Traditional: 'zh-TW',
  Corsican: 'co',
  Croatian: 'hr',
  Czech: 'cs',
  Danish: 'da',
  Dutch: 'nl',
  English: 'en',
  Esperanto: 'eo',
  Estonian: 'et',
  Filipino: 'tl',
  Finnish: 'fi',
  French: 'fr',
  Frisian: 'fy',
  Galician: 'gl',
  Georgian: 'ka',
  German: 'de',
  Greek: 'el',
  Gujarati: 'gu',
  Haitian_Creole: 'ht',
  Hausa: 'ha',
  Hawaiian: 'haw',
  Hebrew: 'iw',
  Hindi: 'hi',
  Hmong: 'hmn',
  Hungarian: 'hu',
  Icelandic: 'is',
  Igbo: 'ig',
  Indonesian: 'id',
  Irish: 'ga',
  Italian: 'it',
  Japanese: 'ja',
  Javanese: 'jw',
  Kannada: 'kn',
  Kazakh: 'kk',
  Khmer: 'km',
  Korean: 'ko',
  Kurdish_Kurmanji: 'ku',
  Kyrgyz: 'ky',
  Lao: 'lo',
  Latin: 'la',
  Latvian: 'lv',
  Lithuanian: 'lt',
  Luxembourgish: 'lb',
  Macedonian: 'mk',
  Malagasy: 'mg',
  Malay: 'ms',
  Malayalam: 'ml',
  Maltese: 'mt',
  Maori: 'mi',
  Marathi: 'mr',
  Mongolian: 'mn',
  Myanmar_Burmese: 'my',
  Nepali: 'ne',
  Norwegian: 'no',
  Pashto: 'ps',
  Persian: 'fa',
  Polish: 'pl',
  Portuguese: 'pt',
  Punjabi: 'pa',
  Romanian: 'ro',
  Russian: 'ru',
  Samoan: 'sm',
  Scots_Gaelic: 'gd',
  Serbian: 'sr',
  Sesotho: 'st',
  Shona: 'sn',
  Sindhi: 'sd',
  Sinhala: 'si',
  Slovak: 'sk',
  Slovenian: 'sl',
  Somali: 'so',
  Spanish: 'es',
  Sundanese: 'su',
  Swahili: 'sw',
  Swedish: 'sv',
  Tajik: 'tg',
  Tamil: 'ta',
  Telugu: 'te',
  Thai: 'th',
  Turkish: 'tr',
  Ukrainian: 'uk',
  Urdu: 'ur',
  Uzbek: 'uz',
  Vietnamese: 'vi',
  Welsh: 'cy',
  Xhosa: 'xh',
  Yiddish: 'yi',
  Yoruba: 'yo',
  Zulu: 'zu'
};
var LibreTranslateLanguages = {
  Automatic: 'auto',
  English: 'en',
  Arabic: 'ar',
  Azerbaijani: 'az',
  Chinese: 'zh',
  Czech: 'cs',
  Danish: 'da',
  Dutch: 'nl',
  Esperanto: 'eo',
  Finnish: 'fi',
  French: 'fr',
  German: 'de',
  Greek: 'el',
  Hebrew: 'iw',
  Hindi: 'hi',
  Hungarian: 'hu',
  Indonesian: 'id',
  Irish: 'ga',
  Italian: 'it',
  Japanese: 'ja',
  Korean: 'ko',
  Persian: 'fa',
  Polish: 'pl',
  Portuguese: 'pt',
  Russian: 'ru',
  Slovak: 'sk',
  Spanish: 'es',
  Swedish: 'sv',
  Turkish: 'tr',
  Ukrainian: 'uk'
};
var ArgosTranslateLanguages = {
  Automatic: 'auto',
  English: 'en',
  Arabic: 'ar',
  Chinese: 'zh',
  French: 'fr',
  German: 'de',
  Hindi: 'hi',
  Indonesian: 'id',
  Irish: 'ga',
  Italian: 'it',
  Japanese: 'ja',
  Korean: 'ko',
  Polish: 'pl',
  Portuguese: 'pt',
  Russian: 'ru',
  Spanish: 'es',
  Turkish: 'tr',
  Vietnamese: 'vi'
};
var BingTranslateLanguages = {
  Automatic: 'auto-detect',
  Afrikaans: 'af',
  Albanian: 'sq',
  Amharic: 'am',
  Arabic: 'ar',
  Armenian: 'hy',
  Assamese: 'as',
  Azerbaijani: 'az',
  Bangla: 'bn',
  Bashkir: 'ba',
  Basque: 'eu',
  Bosnian: 'bs',
  Bulgarian: 'bg',
  Cantonese_Traditional: 'yue',
  Catalan: 'ca',
  Chinese_Literary: 'lzh',
  Chinese_Simplified: 'zh-Hans',
  Chinese_Traditional: 'zh-Hant',
  Croatian: 'hr',
  Czech: 'cs',
  Danish: 'da',
  Dari: 'prs',
  Divehi: 'dv',
  Dutch: 'nl',
  English: 'en',
  Estonian: 'et',
  Faroese: 'fo',
  Fijian: 'fj',
  Filipino: 'fil',
  Finnish: 'fi',
  French: 'fr',
  French_Canada: 'fr-CA',
  Galician: 'gl',
  Georgian: 'ka',
  German: 'de',
  Greek: 'el',
  Gujarati: 'gu',
  Haitian_Creole: 'ht',
  Hebrew: 'he',
  Hindi: 'hi',
  Hmong_Daw: 'mww',
  Hungarian: 'hu',
  Icelandic: 'is',
  Indonesian: 'id',
  Inuinnaqtun: 'ikt',
  Inuktitut: 'iu',
  Inuktitut_Latin: 'iu-Latn',
  Irish: 'ga',
  Italian: 'it',
  Japanese: 'ja',
  Kannada: 'kn',
  Kazakh: 'kk',
  Khmer: 'km',
  Klingon_Latin: 'tlh-Latn',
  Korean: 'ko',
  Kurdish_Central: 'ku',
  Kurdish_Northern: 'kmr',
  Kyrgyz: 'ky',
  Lao: 'lo',
  Latvian: 'lv',
  Lithuanian: 'lt',
  Macedonian: 'mk',
  Malagasy: 'mg',
  Malay: 'ms',
  Malayalam: 'ml',
  Maltese: 'mt',
  Marathi: 'mr',
  Mongolian_Cyrillic: 'mn-Cyrl',
  Mongolian_Traditional: 'mn-Mong',
  Myanmar_Burmese: 'my',
  Māori: 'mi',
  Nepali: 'ne',
  Norwegian: 'nb',
  Odia: 'or',
  Pashto: 'ps',
  Persian: 'fa',
  Polish: 'pl',
  Portuguese_Brazil: 'pt',
  Portuguese_Portugal: 'pt-PT',
  Punjabi: 'pa',
  Querétaro_Otomi: 'otq',
  Romanian: 'ro',
  Russian: 'ru',
  Samoan: 'sm',
  Serbian_Cyrillic: 'sr-Cyrl',
  Serbian_Latin: 'sr-Latn',
  Slovak: 'sk',
  Slovenian: 'sl',
  Somali: 'so',
  Spanish: 'es',
  Swahili: 'sw',
  Swedish: 'sv',
  Tahitian: 'ty',
  Tamil: 'ta',
  Tatar: 'tt',
  Telugu: 'te',
  Thai: 'th',
  Tibetan: 'bo',
  Tigrinya: 'ti',
  Tongan: 'to',
  Turkish: 'tr',
  Turkmen: 'tk',
  Ukrainian: 'uk',
  Upper_Sorbian: 'hsb',
  Urdu: 'ur',
  Uyghur: 'ug',
  Uzbek_Latin: 'uz',
  Vietnamese: 'vi',
  Welsh: 'cy',
  Yucatec_Maya: 'yua',
  Zulu: 'zu'
};
var DeepLTranslateLanguages = {
  Bulgarian: 'BG',
  Chinese: 'ZH',
  Czech: 'CS',
  Danish: 'DA',
  Dutch: 'NL',
  English: 'EN',
  Estonian: 'ET',
  Finnish: 'FI',
  French: 'FR',
  German: 'DE',
  Greek: 'EL',
  Hungarian: 'HU',
  Indonesian: 'ID',
  Italian: 'IT',
  Japanese: 'JA',
  Korean: 'KO',
  Latvian: 'LV',
  Lithuanian: 'LT',
  Norwegian: 'NB',
  Polish: 'PL',
  Portuguese: 'PT',
  Romanian: 'RO',
  Russian: 'RU',
  Slovak: 'SK',
  Slovenian: 'SL',
  Spanish: 'ES',
  Swedish: 'SV',
  Turkish: 'TR',
  Ukrainian: 'UK'
};
var LanguageMapping = {
  Automatic: {
    google: GoogleTranslateLanguages.Automatic,
    google2: GoogleTranslate2Languages.Automatic,
    libre: LibreTranslateLanguages.Automatic,
    argos: ArgosTranslateLanguages.Automatic,
    bing: BingTranslateLanguages.Automatic
  },
  Afrikaans: {
    google: GoogleTranslateLanguages.Afrikaans,
    google2: GoogleTranslateLanguages.Afrikaans,
    bing: BingTranslateLanguages.Afrikaans
  },
  Albanian: {
    google: GoogleTranslateLanguages.Albanian,
    google2: GoogleTranslate2Languages.Albanian,
    bing: BingTranslateLanguages.Albanian
  },
  Amharic: {
    google: GoogleTranslateLanguages.Amharic,
    google2: GoogleTranslate2Languages.Amharic,
    bing: BingTranslateLanguages.Amharic
  },
  Arabic: {
    google: GoogleTranslateLanguages.Arabic,
    google2: GoogleTranslate2Languages.Arabic,
    libre: LibreTranslateLanguages.Arabic,
    argos: ArgosTranslateLanguages.Arabic,
    bing: BingTranslateLanguages.Arabic
  },
  Assamese: {
    bing: BingTranslateLanguages.Assamese
  },
  Armenian: {
    google: GoogleTranslateLanguages.Armenian,
    google2: GoogleTranslate2Languages.Armenian,
    bing: BingTranslateLanguages.Armenian
  },
  Azerbaijani: {
    google: GoogleTranslateLanguages.Azerbaijani,
    google2: GoogleTranslate2Languages.Azerbaijani,
    libre: LibreTranslateLanguages.Azerbaijani,
    bing: BingTranslateLanguages.Azerbaijani
  },
  Bashkir: {
    bing: BingTranslateLanguages.Bashkir
  },
  Basque: {
    google: GoogleTranslateLanguages.Basque,
    google2: GoogleTranslate2Languages.Basque,
    bing: BingTranslateLanguages.Basque
  },
  Belarusian: {
    google: GoogleTranslateLanguages.Belarusian,
    google2: GoogleTranslate2Languages.Belarusian
  },
  Bengali: {
    google: GoogleTranslateLanguages.Bengali,
    google2: GoogleTranslate2Languages.Bengali,
    bing: BingTranslateLanguages.Bangla
  },
  Bosnian: {
    google: GoogleTranslateLanguages.Bosnian,
    google2: GoogleTranslate2Languages.Bosnian,
    bing: BingTranslateLanguages.Bosnian
  },
  Bulgarian: {
    google: GoogleTranslateLanguages.Bulgarian,
    google2: GoogleTranslate2Languages.Bulgarian,
    bing: BingTranslateLanguages.Bulgarian,
    deepl: DeepLTranslateLanguages.Bulgarian
  },
  Cantonese_Traditional: {
    bing: BingTranslateLanguages.Cantonese_Traditional
  },
  Catalan: {
    google: GoogleTranslateLanguages.Catalan,
    google2: GoogleTranslate2Languages.Catalan,
    bing: BingTranslateLanguages.Catalan
  },
  Cebuano: {
    google: GoogleTranslateLanguages.Cebuano,
    google2: GoogleTranslate2Languages.Cebuano
  },
  Chichewa: {
    google: GoogleTranslateLanguages.Chichewa,
    google2: GoogleTranslate2Languages.Chichewa
  },
  Chinese_Literary: {
    bing: BingTranslateLanguages.Chinese_Literary
  },
  Chinese_Simplified: {
    google: GoogleTranslateLanguages.Chinese_Simplified,
    google2: GoogleTranslate2Languages.Chinese_Simplified,
    bing: BingTranslateLanguages.Chinese_Simplified,
    libre: LibreTranslateLanguages.Chinese,
    argos: ArgosTranslateLanguages.Chinese,
    deepl: DeepLTranslateLanguages.Chinese
  },
  Chinese_Traditional: {
    google: GoogleTranslateLanguages.Chinese_Traditional,
    google2: GoogleTranslate2Languages.Chinese_Traditional,
    bing: BingTranslateLanguages.Chinese_Traditional
  },
  Corsican: {
    google: GoogleTranslateLanguages.Corsican,
    google2: GoogleTranslate2Languages.Corsican
  },
  Croatian: {
    google: GoogleTranslateLanguages.Croatian,
    google2: GoogleTranslate2Languages.Croatian,
    bing: BingTranslateLanguages.Croatian
  },
  Czech: {
    google: GoogleTranslateLanguages.Czech,
    google2: GoogleTranslate2Languages.Czech,
    bing: BingTranslateLanguages.Czech,
    libre: LibreTranslateLanguages.Czech,
    deepl: DeepLTranslateLanguages.Czech
  },
  Danish: {
    google: GoogleTranslateLanguages.Danish,
    google2: GoogleTranslate2Languages.Danish,
    bing: BingTranslateLanguages.Danish,
    libre: LibreTranslateLanguages.Danish,
    deepl: DeepLTranslateLanguages.Danish
  },
  Dari: {
    bing: BingTranslateLanguages.Dari
  },
  Divehi: {
    bing: BingTranslateLanguages.Divehi
  },
  Dutch: {
    google: GoogleTranslateLanguages.Dutch,
    google2: GoogleTranslate2Languages.Dutch,
    bing: BingTranslateLanguages.Dutch,
    libre: LibreTranslateLanguages.Dutch,
    deepl: DeepLTranslateLanguages.Dutch
  },
  English: {
    google: GoogleTranslateLanguages.English,
    google2: GoogleTranslate2Languages.English,
    bing: BingTranslateLanguages.English,
    libre: LibreTranslateLanguages.English,
    argos: ArgosTranslateLanguages.English,
    deepl: DeepLTranslateLanguages.English
  },
  Esperanto: {
    google: GoogleTranslateLanguages.Esperanto,
    google2: GoogleTranslate2Languages.Esperanto,
    libre: LibreTranslateLanguages.Esperanto
  },
  Estonian: {
    google: GoogleTranslateLanguages.Estonian,
    google2: GoogleTranslate2Languages.Estonian,
    bing: BingTranslateLanguages.Estonian,
    deepl: DeepLTranslateLanguages.Estonian
  },
  Faroese: {
    bing: BingTranslateLanguages.Faroese
  },
  Fijian: {
    bing: BingTranslateLanguages.Fijian
  },
  Filipino: {
    google: GoogleTranslateLanguages.Filipino,
    google2: GoogleTranslate2Languages.Filipino,
    bing: BingTranslateLanguages.Filipino
  },
  Finnish: {
    google: GoogleTranslateLanguages.Finnish,
    google2: GoogleTranslate2Languages.Finnish,
    bing: BingTranslateLanguages.Finnish,
    libre: LibreTranslateLanguages.Finnish,
    deepl: DeepLTranslateLanguages.Finnish
  },
  French: {
    google: GoogleTranslateLanguages.French,
    google2: GoogleTranslate2Languages.French,
    bing: BingTranslateLanguages.French,
    libre: LibreTranslateLanguages.French,
    argos: ArgosTranslateLanguages.French,
    deepl: DeepLTranslateLanguages.French
  },
  French_Canada: {
    bing: BingTranslateLanguages.French_Canada
  },
  Frisian: {
    google: GoogleTranslateLanguages.Frisian,
    google2: GoogleTranslate2Languages.Frisian
  },
  Galician: {
    google: GoogleTranslateLanguages.Galician,
    google2: GoogleTranslate2Languages.Galician,
    bing: BingTranslateLanguages.Galician
  },
  Georgian: {
    google: GoogleTranslateLanguages.Georgian,
    google2: GoogleTranslate2Languages.Georgian,
    bing: BingTranslateLanguages.Georgian
  },
  German: {
    google: GoogleTranslateLanguages.German,
    google2: GoogleTranslate2Languages.German,
    bing: BingTranslateLanguages.German,
    libre: LibreTranslateLanguages.German,
    argos: ArgosTranslateLanguages.German,
    deepl: DeepLTranslateLanguages.German
  },
  Greek: {
    google: GoogleTranslateLanguages.Greek,
    google2: GoogleTranslate2Languages.Greek,
    bing: BingTranslateLanguages.Greek,
    libre: LibreTranslateLanguages.Greek,
    deepl: DeepLTranslateLanguages.Greek
  },
  Gujarati: {
    google: GoogleTranslateLanguages.Gujarati,
    google2: GoogleTranslate2Languages.Gujarati,
    bing: BingTranslateLanguages.Gujarati
  },
  Haitian_Creole: {
    google: GoogleTranslateLanguages.Haitian_Creole,
    google2: GoogleTranslate2Languages.Haitian_Creole,
    bing: BingTranslateLanguages.Haitian_Creole
  },
  Hausa: {
    google: GoogleTranslateLanguages.Hausa,
    google2: GoogleTranslate2Languages.Hausa
  },
  Hawaiian: {
    google: GoogleTranslateLanguages.Hawaiian,
    google2: GoogleTranslate2Languages.Hawaiian
  },
  Hebrew: {
    google: GoogleTranslateLanguages.Hebrew,
    google2: GoogleTranslate2Languages.Hebrew,
    bing: BingTranslateLanguages.Hebrew,
    libre: LibreTranslateLanguages.Hebrew
  },
  Hindi: {
    google: GoogleTranslateLanguages.Hindi,
    google2: GoogleTranslate2Languages.Hindi,
    bing: BingTranslateLanguages.Hindi,
    libre: LibreTranslateLanguages.Hindi,
    argos: ArgosTranslateLanguages.Hindi
  },
  Hmong: {
    google: GoogleTranslateLanguages.Hmong,
    google2: GoogleTranslate2Languages.Hmong,
    bing: BingTranslateLanguages.Hmong_Daw
  },
  Hungarian: {
    google: GoogleTranslateLanguages.Hungarian,
    google2: GoogleTranslate2Languages.Hungarian,
    bing: BingTranslateLanguages.Hungarian,
    libre: LibreTranslateLanguages.Hungarian,
    deepl: DeepLTranslateLanguages.Hungarian
  },
  Icelandic: {
    google: GoogleTranslateLanguages.Icelandic,
    google2: GoogleTranslate2Languages.Icelandic,
    bing: BingTranslateLanguages.Icelandic
  },
  Igbo: {
    google: GoogleTranslateLanguages.Igbo,
    google2: GoogleTranslate2Languages.Igbo
  },
  Indonesian: {
    google: GoogleTranslateLanguages.Indonesian,
    google2: GoogleTranslate2Languages.Indonesian,
    bing: BingTranslateLanguages.Indonesian,
    libre: LibreTranslateLanguages.Indonesian,
    argos: ArgosTranslateLanguages.Indonesian,
    deepl: DeepLTranslateLanguages.Indonesian
  },
  Inuinnaqtun: {
    bing: BingTranslateLanguages.Inuinnaqtun
  },
  Inuktitut: {
    bing: BingTranslateLanguages.Inuktitut
  },
  Inuktitut_Latin: {
    bing: BingTranslateLanguages.Inuktitut_Latin
  },
  Irish: {
    google: GoogleTranslateLanguages.Irish,
    google2: GoogleTranslate2Languages.Irish,
    bing: BingTranslateLanguages.Irish,
    libre: LibreTranslateLanguages.Irish,
    argos: ArgosTranslateLanguages.Irish
  },
  Italian: {
    google: GoogleTranslateLanguages.Italian,
    google2: GoogleTranslate2Languages.Italian,
    bing: BingTranslateLanguages.Italian,
    libre: LibreTranslateLanguages.Italian,
    argos: ArgosTranslateLanguages.Italian,
    deepl: DeepLTranslateLanguages.Italian
  },
  Japanese: {
    google: GoogleTranslateLanguages.Japanese,
    google2: GoogleTranslate2Languages.Japanese,
    bing: BingTranslateLanguages.Japanese,
    libre: LibreTranslateLanguages.Japanese,
    argos: ArgosTranslateLanguages.Japanese,
    deepl: DeepLTranslateLanguages.Japanese
  },
  Javanese: {
    google: GoogleTranslateLanguages.Javanese,
    google2: GoogleTranslate2Languages.Javanese
  },
  Kannada: {
    google: GoogleTranslateLanguages.Kannada,
    google2: GoogleTranslate2Languages.Kannada,
    bing: BingTranslateLanguages.Kannada
  },
  Kazakh: {
    google: GoogleTranslateLanguages.Kazakh,
    google2: GoogleTranslate2Languages.Kazakh,
    bing: BingTranslateLanguages.Kazakh
  },
  Khmer: {
    google: GoogleTranslateLanguages.Khmer,
    google2: GoogleTranslate2Languages.Khmer,
    bing: BingTranslateLanguages.Khmer
  },
  Klingon_Latin: {
    bing: BingTranslateLanguages.Klingon_Latin
  },
  Korean: {
    google: GoogleTranslateLanguages.Korean,
    google2: GoogleTranslate2Languages.Korean,
    bing: BingTranslateLanguages.Korean,
    libre: LibreTranslateLanguages.Korean,
    argos: ArgosTranslateLanguages.Korean,
    deepl: DeepLTranslateLanguages.Korean
  },
  Kurdish_Kurmanji: {
    google: GoogleTranslateLanguages.Kurdish_Kurmanji,
    google2: GoogleTranslate2Languages.Kurdish_Kurmanji,
    bing: BingTranslateLanguages.Kurdish_Kurmanji
  },
  Kurdish_Northern: {
    bing: BingTranslateLanguages.Kurdish_Northern
  },
  Kyrgyz: {
    google: GoogleTranslateLanguages.Kyrgyz,
    google2: GoogleTranslate2Languages.Kyrgyz,
    bing: BingTranslateLanguages.Kyrgyz
  },
  Lao: {
    google: GoogleTranslateLanguages.Lao,
    google2: GoogleTranslate2Languages.Lao,
    bing: BingTranslateLanguages.Lao
  },
  Latin: {
    google: GoogleTranslateLanguages.Latin,
    google2: GoogleTranslate2Languages.Latin
  },
  Latvian: {
    google: GoogleTranslateLanguages.Latvian,
    google2: GoogleTranslate2Languages.Latvian,
    bing: BingTranslateLanguages.Latvian,
    deepl: DeepLTranslateLanguages.Latvian
  },
  Lithuanian: {
    google: GoogleTranslateLanguages.Lithuanian,
    google2: GoogleTranslate2Languages.Lithuanian,
    bing: BingTranslateLanguages.Lithuanian,
    deepl: DeepLTranslateLanguages.Lithuanian
  },
  Luxembourgish: {
    google: GoogleTranslateLanguages.Luxembourgish,
    google2: GoogleTranslate2Languages.Luxembourgish
  },
  Macedonian: {
    google: GoogleTranslateLanguages.Macedonian,
    google2: GoogleTranslate2Languages.Macedonian,
    bing: BingTranslateLanguages.Macedonian
  },
  Malagasy: {
    google: GoogleTranslateLanguages.Malagasy,
    google2: GoogleTranslate2Languages.Malagasy,
    bing: BingTranslateLanguages.Malagasy
  },
  Malay: {
    google: GoogleTranslateLanguages.Malay,
    google2: GoogleTranslate2Languages.Malay,
    bing: BingTranslateLanguages.Malay
  },
  Malayalam: {
    google: GoogleTranslateLanguages.Malayalam,
    google2: GoogleTranslate2Languages.Malayalam,
    bing: BingTranslateLanguages.Malayalam
  },
  Maltese: {
    google: GoogleTranslateLanguages.Maltese,
    google2: GoogleTranslate2Languages.Maltese,
    bing: BingTranslateLanguages.Maltese
  },
  Maori: {
    google: GoogleTranslateLanguages.Maori,
    google2: GoogleTranslate2Languages.Maori,
    bing: BingTranslateLanguages.Māori
  },
  Marathi: {
    google: GoogleTranslateLanguages.Marathi,
    google2: GoogleTranslate2Languages.Marathi,
    bing: BingTranslateLanguages.Marathi
  },
  Mongolian: {
    google: GoogleTranslateLanguages.Marathi,
    google2: GoogleTranslate2Languages.Marathi,
    bing: BingTranslateLanguages.Mongolian_Traditional
  },
  Mongolian_Cyrillic: {
    bing: BingTranslateLanguages.Mongolian_Cyrillic
  },
  Myanmar_Burmese: {
    google: GoogleTranslateLanguages.Myanmar_Burmese,
    google2: GoogleTranslate2Languages.Myanmar_Burmese,
    bing: BingTranslateLanguages.Myanmar_Burmese
  },
  Nepali: {
    google: GoogleTranslateLanguages.Nepali,
    google2: GoogleTranslate2Languages.Nepali,
    bing: BingTranslateLanguages.Nepali
  },
  Norwegian: {
    google: GoogleTranslateLanguages.Norwegian,
    google2: GoogleTranslate2Languages.Norwegian,
    bing: BingTranslateLanguages.Norwegian,
    deepl: DeepLTranslateLanguages.Norwegian
  },
  Odia: {
    bing: BingTranslateLanguages.Odia
  },
  Pashto: {
    google: GoogleTranslateLanguages.Pashto,
    google2: GoogleTranslate2Languages.Pashto,
    bing: BingTranslateLanguages.Pashto
  },
  Persian: {
    google: GoogleTranslateLanguages.Persian,
    google2: GoogleTranslate2Languages.Persian,
    bing: BingTranslateLanguages.Persian,
    libre: LibreTranslateLanguages.Persian
  },
  Polish: {
    google: GoogleTranslateLanguages.Polish,
    google2: GoogleTranslate2Languages.Polish,
    bing: BingTranslateLanguages.Polish,
    libre: LibreTranslateLanguages.Polish,
    argos: ArgosTranslateLanguages.Polish,
    deepl: DeepLTranslateLanguages.Polish
  },
  Portuguese: {
    google: GoogleTranslateLanguages.Portuguese,
    google2: GoogleTranslate2Languages.Portuguese,
    bing: BingTranslateLanguages.Portuguese_Portugal,
    libre: LibreTranslateLanguages.Portuguese,
    argos: ArgosTranslateLanguages.Portuguese,
    deepl: DeepLTranslateLanguages.Portuguese
  },
  Portuguese_Brazil: {
    bing: BingTranslateLanguages.Portuguese_Brazil
  },
  Punjabi: {
    google: GoogleTranslateLanguages.Punjabi,
    google2: GoogleTranslate2Languages.Punjabi,
    bing: BingTranslateLanguages.Punjabi
  },
  Querétaro_Otomi: {
    bing: BingTranslateLanguages.Querétaro_Otomi
  },
  Romanian: {
    google: GoogleTranslateLanguages.Romanian,
    google2: GoogleTranslate2Languages.Romanian,
    bing: BingTranslateLanguages.Romanian,
    deepl: DeepLTranslateLanguages.Romanian
  },
  Russian: {
    google: GoogleTranslateLanguages.Russian,
    google2: GoogleTranslate2Languages.Russian,
    bing: BingTranslateLanguages.Russian,
    libre: LibreTranslateLanguages.Russian,
    argos: ArgosTranslateLanguages.Russian,
    deepl: DeepLTranslateLanguages.Russian
  },
  Samoan: {
    google: GoogleTranslateLanguages.Samoan,
    google2: GoogleTranslate2Languages.Samoan,
    bing: BingTranslateLanguages.Samoan
  },
  Scots_Gaelic: {
    google: GoogleTranslateLanguages.Scots_Gaelic,
    google2: GoogleTranslate2Languages.Scots_Gaelic
  },
  Serbian: {
    google: GoogleTranslateLanguages.Serbian,
    google2: GoogleTranslate2Languages.Serbian,
    bing: BingTranslateLanguages.Serbian_Latin
  },
  Serbian_Cyrillic: {
    bing: BingTranslateLanguages.Serbian_Cyrillic
  },
  Sesotho: {
    google: GoogleTranslateLanguages.Sesotho,
    google2: GoogleTranslate2Languages.Sesotho
  },
  Shona: {
    google: GoogleTranslateLanguages.Shona,
    google2: GoogleTranslate2Languages.Shona
  },
  Sindhi: {
    google: GoogleTranslateLanguages.Sindhi,
    google2: GoogleTranslate2Languages.Sindhi
  },
  Sinhala: {
    google: GoogleTranslateLanguages.Sinhala,
    google2: GoogleTranslate2Languages.Sinhala
  },
  Slovak: {
    google: GoogleTranslateLanguages.Slovak,
    google2: GoogleTranslate2Languages.Slovak,
    bing: BingTranslateLanguages.Slovak,
    libre: LibreTranslateLanguages.Slovak,
    deepl: DeepLTranslateLanguages.Slovak
  },
  Slovenian: {
    google: GoogleTranslateLanguages.Slovenian,
    google2: GoogleTranslate2Languages.Slovenian,
    bing: BingTranslateLanguages.Slovenian,
    deepl: DeepLTranslateLanguages.Slovenian
  },
  Somali: {
    google: GoogleTranslateLanguages.Somali,
    google2: GoogleTranslate2Languages.Somali,
    bing: BingTranslateLanguages.Somali
  },
  Spanish: {
    google: GoogleTranslateLanguages.Spanish,
    google2: GoogleTranslate2Languages.Spanish,
    bing: BingTranslateLanguages.Spanish,
    libre: LibreTranslateLanguages.Spanish,
    argos: ArgosTranslateLanguages.Spanish,
    deepl: DeepLTranslateLanguages.Spanish
  },
  Sundanese: {
    google: GoogleTranslateLanguages.Sundanese,
    google2: GoogleTranslate2Languages.Sundanese
  },
  Swahili: {
    google: GoogleTranslateLanguages.Swahili,
    google2: GoogleTranslate2Languages.Swahili,
    bing: BingTranslateLanguages.Swahili
  },
  Swedish: {
    google: GoogleTranslateLanguages.Swedish,
    google2: GoogleTranslate2Languages.Swedish,
    bing: BingTranslateLanguages.Swedish,
    libre: LibreTranslateLanguages.Swedish,
    deepl: DeepLTranslateLanguages.Swedish
  },
  Tahitian: {
    bing: BingTranslateLanguages.Tahitian
  },
  Tajik: {
    google: GoogleTranslateLanguages.Tajik,
    google2: GoogleTranslate2Languages.Tajik
  },
  Tamil: {
    google: GoogleTranslateLanguages.Tamil,
    google2: GoogleTranslate2Languages.Tamil,
    bing: BingTranslateLanguages.Tamil
  },
  Tatar: {
    bing: BingTranslateLanguages.Tatar
  },
  Telugu: {
    google: GoogleTranslateLanguages.Telugu,
    google2: GoogleTranslate2Languages.Telugu,
    bing: BingTranslateLanguages.Telugu
  },
  Thai: {
    google: GoogleTranslateLanguages.Thai,
    google2: GoogleTranslate2Languages.Thai,
    bing: BingTranslateLanguages.Thai
  },
  Tibetan: {
    bing: BingTranslateLanguages.Tibetan
  },
  Tigrinya: {
    bing: BingTranslateLanguages.Tigrinya
  },
  Tongan: {
    bing: BingTranslateLanguages.Tongan
  },
  Turkish: {
    google: GoogleTranslateLanguages.Turkish,
    google2: GoogleTranslate2Languages.Turkish,
    bing: BingTranslateLanguages.Turkish,
    libre: LibreTranslateLanguages.Turkish,
    argos: ArgosTranslateLanguages.Turkish,
    deepl: DeepLTranslateLanguages.Turkish
  },
  Turkmen: {
    bing: BingTranslateLanguages.Turkmen
  },
  Ukrainian: {
    google: GoogleTranslateLanguages.Ukrainian,
    google2: GoogleTranslate2Languages.Ukrainian,
    bing: BingTranslateLanguages.Ukrainian,
    libre: LibreTranslateLanguages.Ukrainian,
    deepl: DeepLTranslateLanguages.Ukrainian
  },
  Upper_Sorbian: {
    bing: BingTranslateLanguages.Upper_Sorbian
  },
  Urdu: {
    google: GoogleTranslateLanguages.Urdu,
    google2: GoogleTranslate2Languages.Urdu,
    bing: BingTranslateLanguages.Urdu
  },
  Uyghur: {
    bing: BingTranslateLanguages.Uyghur
  },
  Uzbek: {
    google: GoogleTranslateLanguages.Uzbek,
    google2: GoogleTranslate2Languages.Uzbek,
    bing: BingTranslateLanguages.Uzbek_Latin
  },
  Vietnamese: {
    google: GoogleTranslateLanguages.Vietnamese,
    google2: GoogleTranslate2Languages.Vietnamese,
    bing: BingTranslateLanguages.Vietnamese,
    argos: ArgosTranslateLanguages.Vietnamese
  },
  Welsh: {
    google: GoogleTranslateLanguages.Welsh,
    google2: GoogleTranslate2Languages.Welsh,
    bing: BingTranslateLanguages.Welsh
  },
  Xhosa: {
    google: GoogleTranslateLanguages.Xhosa,
    google2: GoogleTranslate2Languages.Xhosa
  },
  Yiddish: {
    google: GoogleTranslateLanguages.Yiddish,
    google2: GoogleTranslate2Languages.Yiddish
  },
  Yoruba: {
    google: GoogleTranslateLanguages.Yoruba,
    google2: GoogleTranslate2Languages.Yoruba
  },
  Yucatec_Maya: {
    bing: BingTranslateLanguages.Yucatec_Maya
  },
  Zulu: {
    google: GoogleTranslateLanguages.Zulu,
    google2: GoogleTranslate2Languages.Zulu,
    bing: BingTranslateLanguages.Zulu
  }
};

var figlet = /*#__PURE__*/require('figlet');
var cli_name = 'jsontt';
var default_color = '\x1b[0m';
var success_color = '\x1b[32m';
var error_color = '\x1b[31m';
var info_color = '\x1b[34m';
var warn_color = '\x1b[33m';
function success(message) {
  console.log(success_color, "" + message, default_color);
}
function error(message) {
  console.log(error_color, "" + message, default_color);
}
function info(message) {
  console.log(info_color, "" + message, default_color);
}
function warn(message) {
  console.log(warn_color, "" + message, default_color);
}
var supportedLanguagesUrl = "\nsupported Languages: " + info_color + "https://github.com/mololab/json-translator/blob/master/docs/LANGUAGES.md" + default_color + "\n";
var messages = {
  cli: {
    // cli general messages
    welcome: "\n" + warn_color + "Sponsored by Moniesto - Bridge between Traders and Investors in Crypto \nhttps://moniesto.com  \n\n" + default_color + "Welcome to the\n" + (success_color + /*#__PURE__*/figlet.textSync('jsontt')) + default_color + "\n\t\t\t\tcli " + current_version + "\n",
    description: 'This CLI will provide you the ability to translate your JSON/YAML files or JSON objects into different languages for free.',
    usage: "<your/path/to/file.json>",
    usage_with_proxy: "Usage with proxy list file (only supported for Google module): " + cli_name + " <your/path/to/file.json> <your/path/to/proxy_list.txt>",
    usage_by_ops: "Usage with options: " + cli_name + " <your/path/to/file.json> --module <TranslationModules> --from <Language> --to <Languages...>",
    paths: 'required json file path <path/file.json> or json file with proxy list txt file path <your/path/to/file.json> <your/path/to/proxy_list.txt>',
    // cli usage messages
    module: 'specify translation module | e.g., -m google',
    from: 'from language | e.g., -f en',
    to: 'to translates | e.g., -t ar fr zh-CN',
    new_file_name: 'optional ↵ | output filename | e.g., -n myApp',
    fallback: 'optional ↵ | fallback logic, try other translation modules on fail | yes, no | default: no | e.g., -f yes',
    concurrency_limit: 'optional ↵ | set max concurrency limit (higher faster, but easy to get banned) | default: 3 | e.g., -cl 5',
    // cli prompt messages
    select_module_message: 'Select translation module:',
    from_message: 'From which language?',
    to_message: 'To which language | languages? (Can select more than one with space bar)',
    new_file_name_message: 'optional ↵ | Output filename',
    fallback_message: 'optional ↵ | fallback logic, try other translation modules when fail | yes, no | default: no',
    concurrency_limit_message: 'optional ↵ | set max concurrency limit (higher faster, but easy to get banned) | default: 3',
    // fail messages
    module_not_available: "module is not available. (choices : " + translationModuleKeys + ")",
    from_not_available: "translate language from is not available\n" + supportedLanguagesUrl,
    to_not_available: "languages to translate into is not available\n" + supportedLanguagesUrl,
    no_selected_language: 'You didn`t select any language. Please try it again and select languages with the space bar.',
    fallback_not_available: "fallback input is not available. (choices : " + /*#__PURE__*/Object.keys(fallbacks) + ")",
    proxy_file_notValid_or_not_empty_options: "\n    - Please ensure that the value for the option \"-m, --module <Translation>\" is compatible\n    - Please ensure that the value for the option \"-f, --from <Language>\" is compatible\n    - nPlease ensure that the value for the option \"-t, --to <Languages...>\" is compatible\n    - Please ensure that the value for the option \"-n, --name <string>\" is valid\n    - Please ensure that the value for the option \"-f, --fallback <string>\" is valid\n    - Please ensure that the value for the option \"-cl, --concurrencylimit <number>\" is valid\n    - Please make sure to provide a valid path for the proxy list file at \"<your/path/to/proxy_list.txt>\".\n    ",
    // success messages
    creation_done: 'All files are created! You can find them in the same folder as the original file.'
  },
  object: {},
  file: {
    no_path: "The path is not provided.",
    no_file_in_path: "Could not find the file in the path.",
    cannot_translate: "Could not translate the file.",
    cannot_save_file: "Could not save the file."
  }
};

function translateWithLibre(_x, _x2, _x3) {
  return _translateWithLibre.apply(this, arguments);
}
function _translateWithLibre() {
  _translateWithLibre = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(str, from, to) {
    var body, _yield$axios$post, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            body = {
              q: safeValueTransition(str),
              source: from,
              target: to,
              format: 'text',
              api_key: '',
              secret: 'YK4VRVW'
            };
            _context.next = 3;
            return axios.post('https://libretranslate.com/translate', body, {
              headers: {
                Origin: 'https://libretranslate.com'
              }
            });
          case 3:
            _yield$axios$post = _context.sent;
            data = _yield$axios$post.data;
            return _context.abrupt("return", data.translatedText);
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _translateWithLibre.apply(this, arguments);
}
function translateWithArgos(_x4, _x5, _x6) {
  return _translateWithArgos.apply(this, arguments);
}
function _translateWithArgos() {
  _translateWithArgos = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(str, from, to) {
    var body, _yield$axios$post2, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            body = {
              q: safeValueTransition(str),
              source: from,
              target: to
            };
            _context2.next = 3;
            return axios.post('https://translate.argosopentech.com/translate', body, {
              headers: {
                Origin: 'https://translate.argosopentech.com',
                Referer: 'https://translate.argosopentech.com'
              }
            });
          case 3:
            _yield$axios$post2 = _context2.sent;
            data = _yield$axios$post2.data;
            return _context2.abrupt("return", data.translatedText);
          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _translateWithArgos.apply(this, arguments);
}
function translateWithBing(_x7, _x8, _x9) {
  return _translateWithBing.apply(this, arguments);
}
function _translateWithBing() {
  _translateWithBing = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(str, from, to) {
    var _yield$bingTranslator, translation;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return translate$1(safeValueTransition(str), from, to, false);
          case 2:
            _yield$bingTranslator = _context3.sent;
            translation = _yield$bingTranslator.translation;
            return _context3.abrupt("return", translation);
          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _translateWithBing.apply(this, arguments);
}
function translateWithGoogle(_x10, _x11, _x12) {
  return _translateWithGoogle.apply(this, arguments);
}
function _translateWithGoogle() {
  _translateWithGoogle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(str, from, to) {
    var proxy, agent, translatedStr, _translatedStr, _translatedStr2;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(global.proxyList && global.proxyList.length > 0 && global.proxyIndex !== -1)) {
              _context4.next = 18;
              break;
            }
            proxy = global.proxyList[global.proxyIndex]; // step: new proxy exist
            if (!proxy) {
              _context4.next = 10;
              break;
            }
            agent = createHttpProxyAgent("http://" + proxy);
            _context4.next = 6;
            return translateWithGoogleByProxySupport(str, from, to, {
              agent: agent,
              timeout: 4000
            });
          case 6:
            translatedStr = _context4.sent;
            return _context4.abrupt("return", translatedStr);
          case 10:
            warn('No new proxy exists, continuing without proxy');
            global.proxyIndex = -1;
            _context4.next = 14;
            return translateWithGoogleByProxySupport(str, from, to);
          case 14:
            _translatedStr = _context4.sent;
            return _context4.abrupt("return", _translatedStr);
          case 16:
            _context4.next = 22;
            break;
          case 18:
            _context4.next = 20;
            return translateWithGoogleByProxySupport(str, from, to);
          case 20:
            _translatedStr2 = _context4.sent;
            return _context4.abrupt("return", _translatedStr2);
          case 22:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _translateWithGoogle.apply(this, arguments);
}
function translateWithGoogleByProxySupport(_x13, _x14, _x15, _x16) {
  return _translateWithGoogleByProxySupport.apply(this, arguments);
}
function _translateWithGoogleByProxySupport() {
  _translateWithGoogleByProxySupport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(str, from, to, options) {
    var _yield$translate, text;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return translate$2(safeValueTransition(str), {
              from: from,
              to: to,
              fetchOptions: {
                agent: options !== undefined ? options.agent : undefined
              }
            });
          case 2:
            _yield$translate = _context5.sent;
            text = _yield$translate.text;
            return _context5.abrupt("return", text);
          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _translateWithGoogleByProxySupport.apply(this, arguments);
}
function translateWithDeepL(_x17, _x18, _x19) {
  return _translateWithDeepL.apply(this, arguments);
}
function _translateWithDeepL() {
  _translateWithDeepL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(str, from, to) {
    var DEEPL_API_KEY, body, _yield$axios$post3, data;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            DEEPL_API_KEY = process.env.DEEPL_API_KEY;
            if (DEEPL_API_KEY) {
              _context6.next = 3;
              break;
            }
            throw new Error('process.env.DEEPL_API_KEY is not defined');
          case 3:
            body = {
              text: [safeValueTransition(str)],
              target_lang: to,
              source_lang: from
            };
            _context6.next = 6;
            return axios.post('https://api-free.deepl.com/v2/translate', body, {
              headers: {
                Authorization: "DeepL-Auth-Key " + DEEPL_API_KEY,
                'Content-Type': 'application/json'
              }
            });
          case 6:
            _yield$axios$post3 = _context6.sent;
            data = _yield$axios$post3.data;
            return _context6.abrupt("return", data.translations[0].text);
          case 9:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _translateWithDeepL.apply(this, arguments);
}
function translateWithGoogle2(_x20, _x21, _x22) {
  return _translateWithGoogle2.apply(this, arguments);
}
function _translateWithGoogle2() {
  _translateWithGoogle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(str, from, to) {
    var response;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return translate2(str, {
              from: from,
              to: to
            });
          case 2:
            response = _context7.sent;
            return _context7.abrupt("return", response.text);
          case 4:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _translateWithGoogle2.apply(this, arguments);
}

var TranslationModules = {
  google: {
    name: 'Google Translate',
    altName: "[FREE] Google Translate (104 languages)",
    languages: GoogleTranslateLanguages,
    translate: translateWithGoogle
  },
  google2: {
    name: 'Google Translate 2',
    altName: "[FREE] Google Translate 2 (104 languages)",
    languages: GoogleTranslate2Languages,
    translate: translateWithGoogle2
  },
  bing: {
    name: 'Bing Translate',
    altName: '[FREE] Bing Microsoft Translate (110 languages)',
    languages: BingTranslateLanguages,
    translate: translateWithBing
  },
  libre: {
    name: 'Libre Translate',
    altName: "[FREE] Libre Translate (29 languages)",
    languages: LibreTranslateLanguages,
    translate: translateWithLibre
  },
  argos: {
    name: 'Argos Translate',
    altName: "[FREE] Argos Translate (17 languages)",
    languages: ArgosTranslateLanguages,
    translate: translateWithArgos
  },
  deepl: {
    name: 'DeepL Translate',
    altName: 'DeepL Translate (29 languages) \x1b[33m**NEW**\x1b[0m',
    requirements: ['"DEEPL_API_KEY" as env'],
    languages: DeepLTranslateLanguages,
    translate: translateWithDeepL
  }
};

function safeValueTransition(value) {
  var value_safety = valueIsSafe(value);
  if (value_safety.is_safe === true) {
    return value;
  }
  switch (value_safety.type) {
    case nonSafeTypes["null"]:
    case nonSafeTypes.undefined:
    case nonSafeTypes.empty:
      value = default_value;
      break;
    case nonSafeTypes["long"]:
      value = value.substring(0, translation_value_limit);
      break;
  }
  return value;
}
function valueIsSafe(value) {
  var result = {
    is_safe: true,
    type: undefined
  };
  if (value === undefined) {
    result.is_safe = false;
    result['type'] = nonSafeTypes.undefined;
    return result;
  }
  if (value === null) {
    result.is_safe = false;
    result['type'] = nonSafeTypes["null"];
    return result;
  }
  if (value.length >= translation_value_limit) {
    result.is_safe = false;
    result['type'] = nonSafeTypes["long"];
    return result;
  }
  if (value === '') {
    result.is_safe = false;
    result['type'] = nonSafeTypes.empty;
    return result;
  }
  return result;
}
var nonSafeTypes;
(function (nonSafeTypes) {
  nonSafeTypes[nonSafeTypes["long"] = 0] = "long";
  nonSafeTypes[nonSafeTypes["undefined"] = 1] = "undefined";
  nonSafeTypes[nonSafeTypes["null"] = 2] = "null";
  nonSafeTypes[nonSafeTypes["empty"] = 3] = "empty";
})(nonSafeTypes || (nonSafeTypes = {}));
function translationModuleKeys() {
  return Object.keys(TranslationModules);
}
function getTranslationModuleByKey(key) {
  return TranslationModules[key];
}
function getLanguageKeyFromValue(value, languages) {
  return Object.keys(languages).find(function (key) {
    return languages[key] === value;
  });
}
function getLanguageVariant(source, sourceValue, destination) {
  var destinationValue = undefined;
  for (var _i = 0, _Object$keys = Object.keys(LanguageMapping); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (LanguageMapping[key][source] !== undefined && LanguageMapping[key][source] === sourceValue && LanguageMapping[key][destination] !== undefined) {
      destinationValue = LanguageMapping[key][destination];
      break;
    }
  }
  return destinationValue;
}

/**
 *
 * @param objectPath path to file
 * @returns File extension without leading "." ("yml" or "yaml")
 */
var matchYamlExt = function matchYamlExt(objectPath) {
  var _objectPath$match;
  return (_objectPath$match = objectPath.match(/\.(ya?ml)$/)) == null ? void 0 : _objectPath$match[1];
};

function getFile(_x) {
  return _getFile.apply(this, arguments);
}
function _getFile() {
  _getFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(objectPath) {
    var json_file;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            json_file = undefined;
            _context.next = 3;
            return readFile(objectPath, 'utf8').then(function (data) {
              // This function should return a string with JSON-encoded data.
              // To preserve the contract, YAML files should be parsed to object
              // and then stringified to JSON string.
              json_file = matchYamlExt(objectPath) ? JSON.stringify(parse(data)) : data;
            })["catch"](function (_) {
              json_file = undefined;
            });
          case 3:
            return _context.abrupt("return", json_file);
          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getFile.apply(this, arguments);
}
function getRootFolder(path) {
  var arr = path.split('/');
  arr.pop();
  var root = arr.join('/');
  if (root === undefined || root === '') {
    root = './';
  }
  return root;
}
function saveFilePublic(_x2, _x3) {
  return _saveFilePublic.apply(this, arguments);
}
function _saveFilePublic() {
  _saveFilePublic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, data) {
    var json;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // When path extension is for YAML file, then stringify with YAML encoder.
            // Otherwise, default JSON encoder is used.
            json = matchYamlExt(path) ? stringify(data) : JSON.stringify(data);
            _context2.next = 3;
            return writeFile(path, json, 'utf8').then(function (_) {})["catch"](function (_) {
              error(messages.file.cannot_save_file);
            });
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _saveFilePublic.apply(this, arguments);
}

function map(str) {
  // encode urls if exists in the str
  str = urlEncoder(str);
  var _mapByDoubleBracket = mapByDoubleBracket(str),
    double_brackets_map = _mapByDoubleBracket.map,
    initial_ignored_word = _mapByDoubleBracket.word;
  var _mapBySingleBracket = mapBySingleBracket(initial_ignored_word),
    single_brackets_map = _mapBySingleBracket.map,
    ignored_word = _mapBySingleBracket.word;
  return {
    word: ignored_word,
    double_brackets_map: double_brackets_map,
    single_brackets_map: single_brackets_map
  };
}
function unMap(str, double_brackets_map, single_brackets_map) {
  var word = unmapBySingleBracket(str, single_brackets_map);
  word = unmapByDoubleBracket(word, double_brackets_map);
  // decode urls if exists in the str
  word = urlDecoder(word);
  return word;
}
function mapBySingleBracket(str) {
  return mapIgnoredValues(str, '{', '}', '{', '}');
}
function unmapBySingleBracket(str, map) {
  return unmapIgnoredValues(str, map, '{', '}', '{', '}');
}
function mapByDoubleBracket(str) {
  return mapIgnoredValues(str, '{{', '}}', '{', '}');
}
function unmapByDoubleBracket(str, map) {
  return unmapIgnoredValues(str, map, '{{', '}}', '{', '}');
}
function mapIgnoredValues(str, start, end, replaced_start, replaced_end) {
  var counter = 0;
  var map = {};
  var regex = new RegExp(start + "(.*?)" + end, 'g');
  var new_str = str.replace(regex, function (word) {
    word = word.substring(start.length, word.length - end.length);
    // const key = "*".repeat(counter)
    var key = counter;
    map["" + key] = word;
    var locked_ignored = replaced_start + key + replaced_end;
    counter++;
    return locked_ignored;
  });
  return {
    word: new_str,
    map: map
  };
}
function unmapIgnoredValues(str, map, start, end, replaced_start, replaced_end) {
  for (var _i = 0, _Object$entries = Object.entries(map); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
      key = _Object$entries$_i[0],
      value = _Object$entries$_i[1];
    var for_replace = replaced_start + key + replaced_end;
    str = str.replace(for_replace, start + value + end);
  }
  return str;
}
// URL detector & encode AND decoder
function urlEncoder(text) {
  // url finder regex => url
  var regex = /(?:(?:https?|ftp|file):\/\/|www\.|ftp\.)(?:\([-A-Z0-9+&@#\/%=~_|$?!;:,.]*\)|[-A-Z0-9+&@#\/%=~_|$?!;:,.])*(?:\([-A-Z0-9+&@#\/%=~_|$?!;:,.]*\)|[A-Z0-9+&@#\/%=~_|$])/gim;
  var new_text = text.replace(regex, function (url) {
    url = "{" + url + "}";
    return url;
  });
  return new_text;
}
function urlDecoder(text) {
  // url finder regex => {url}
  var regex = /{(?:(?:https?|ftp|file):\/\/|www\.|ftp\.)(?:\([-A-Z0-9+&@#\/%=~_|$?!;:,.]*\)|[-A-Z0-9+&@#\/%=~_|$?!;:,.])*(?:\([-A-Z0-9+&@#\/%=~_|$?!;:,.]*\)|[A-Z0-9+&@#\/%=~_|$])}/gim;
  var new_text = text.replace(regex, function (url) {
    url = url.substring(1, url.length - 1);
    return url;
  });
  return new_text;
}

function plaintranslate(_x, _x2, _x3, _x4, _x5) {
  return _plaintranslate.apply(this, arguments);
}
function _plaintranslate() {
  _plaintranslate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(TranslationConfig, str, from, to, skipModuleKeys) {
    var _ignorer$map, ignored_str, double_brackets_map, single_brackets_map, translatedStr, clonedTranslationConfig, clonedSkipModuleKeys, _newTranslationModule, newModuleKey, newFrom, newTo, stop;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // step: map the subset of string need to be ignored
            _ignorer$map = map(str), ignored_str = _ignorer$map.word, double_brackets_map = _ignorer$map.double_brackets_map, single_brackets_map = _ignorer$map.single_brackets_map; // step: translate in try-catch to keep continuity
            _context.prev = 1;
            _context.next = 4;
            return TranslationConfig.TranslationModule.translate(ignored_str, from, to);
          case 4:
            translatedStr = _context.sent;
            // step: put ignored values back
            translatedStr = unMap(translatedStr, double_brackets_map, single_brackets_map);
            global.totalTranslated = global.totalTranslated + 1;
            return _context.abrupt("return", translatedStr);
          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            // error case
            clonedTranslationConfig = Object.assign({}, TranslationConfig); // cloning to escape ref value
            clonedSkipModuleKeys = Object.assign([], skipModuleKeys); // cloning to escape ref value
            clonedSkipModuleKeys.push(clonedTranslationConfig.moduleKey);
            _newTranslationModule = newTranslationModule(clonedTranslationConfig.moduleKey, clonedSkipModuleKeys, from, to), newModuleKey = _newTranslationModule.newModuleKey, newFrom = _newTranslationModule.newFrom, newTo = _newTranslationModule.newTo;
            stop = !clonedTranslationConfig.fallback || newModuleKey === undefined;
            if (!stop) {
              _context.next = 21;
              break;
            }
            warn("\nerror while translating \"" + str + "\" using " + clonedTranslationConfig.moduleKey + ". Assigned \"--\" instead of exit from cli.");
            global.totalTranslated = global.totalTranslated + 1;
            return _context.abrupt("return", default_value);
          case 21:
            warn("\nerror while translating \"" + str + "\" using " + clonedTranslationConfig.moduleKey + ". Tried: " + clonedSkipModuleKeys + ". Trying " + newModuleKey + ".");
            // update the TranslationModule for next try
            clonedTranslationConfig.TranslationModule = getTranslationModuleByKey(newModuleKey);
            clonedTranslationConfig.moduleKey = newModuleKey;
            return _context.abrupt("return", plaintranslate(clonedTranslationConfig, str, newFrom, newTo, clonedSkipModuleKeys));
          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));
  return _plaintranslate.apply(this, arguments);
}
function newTranslationModule(sourceModuleKeys, skipModuleKeys, from, to) {
  var default_data = {
    newModuleKey: undefined,
    newFrom: undefined,
    newTo: undefined
  };
  var allModuleKeys = translationModuleKeys();
  var result = allModuleKeys.filter(function (item) {
    return !skipModuleKeys.includes(item);
  });
  var newModuleKey = result[0];
  if (!newModuleKey) {
    return default_data; // default
  }

  var newFrom = getLanguageVariant(sourceModuleKeys, from, newModuleKey);
  var newTo = getLanguageVariant(sourceModuleKeys, to, newModuleKey);
  if (!newFrom || !newTo) {
    return default_data; // default
  }
  // has valid newModuleKey & from & to
  return {
    newModuleKey: newModuleKey,
    newFrom: newFrom,
    newTo: newTo
  };
}

var queue = /*#__PURE__*/new TaskQueue(Promise$1, default_concurrency_limit);
function objectTranslator(_x, _x2, _x3, _x4) {
  return _objectTranslator.apply(this, arguments);
}
function _objectTranslator() {
  _objectTranslator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(TranslationConfig, object, from, to) {
    var generalObject;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            queue.concurrency = TranslationConfig.concurrencyLimit;
            if (!(object && from && to)) {
              _context2.next = 8;
              break;
            }
            generalObject = [];
            _context2.next = 5;
            return Promise.all(Object.keys(to).map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(index) {
                var indexAsNum, copyObject;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        indexAsNum = Number(index);
                        copyObject = JSON.parse(JSON.stringify(object));
                        _context.next = 4;
                        return deepDiver(TranslationConfig, copyObject, from, to[indexAsNum]);
                      case 4:
                        generalObject[indexAsNum] = _context.sent;
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return function (_x9) {
                return _ref.apply(this, arguments);
              };
            }()));
          case 5:
            return _context2.abrupt("return", generalObject);
          case 8:
            throw new Error("Undefined values detected. Available ones: object: " + !!object + ", from: " + !!from + ", to: " + !!to);
          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _objectTranslator.apply(this, arguments);
}
function deepDiver(_x5, _x6, _x7, _x8) {
  return _deepDiver.apply(this, arguments);
}
function _deepDiver() {
  _deepDiver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(TranslationConfig, object, from, to) {
    var has;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            has = Object.prototype.hasOwnProperty.bind(object);
            if (!(object === null)) {
              _context5.next = 3;
              break;
            }
            return _context5.abrupt("return", null);
          case 3:
            _context5.next = 5;
            return Promise.all(Object.keys(object).map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(k) {
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!has(k)) {
                          _context4.next = 9;
                          break;
                        }
                        _context4.t0 = typeof object[k];
                        _context4.next = _context4.t0 === 'object' ? 4 : _context4.t0 === 'string' ? 7 : 9;
                        break;
                      case 4:
                        _context4.next = 6;
                        return deepDiver(TranslationConfig, object[k], from, to);
                      case 6:
                        return _context4.abrupt("break", 9);
                      case 7:
                        global.totalTranslation = global.totalTranslation + 1;
                        return _context4.abrupt("return", queue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  _context3.next = 2;
                                  return plaintranslate(TranslationConfig, object[k], from, to, []).then(function (data) {
                                    object[k] = data;
                                  })["catch"](function (err) {
                                    // TODO: return error
                                    console.log('Translation error:', err);
                                  });
                                case 2:
                                  return _context3.abrupt("return", _context3.sent);
                                case 3:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3);
                        }))));
                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              return function (_x10) {
                return _ref2.apply(this, arguments);
              };
            }()));
          case 5:
            return _context5.abrupt("return", object);
          case 6:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _deepDiver.apply(this, arguments);
}

function fileTranslator(_x, _x2, _x3, _x4, _x5) {
  return _fileTranslator.apply(this, arguments);
}
function _fileTranslator() {
  _fileTranslator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(TranslationConfig, tempObjectPath, from, to, newFileName) {
    var _yield$getFileFromPat, jsonObj, objectPath, newJsonObj, latestPath, fileExt, rootFolder;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getFileFromPath(tempObjectPath);
          case 2:
            _yield$getFileFromPat = _context2.sent;
            jsonObj = _yield$getFileFromPat.jsonObj;
            objectPath = _yield$getFileFromPat.objectPath;
            if (!(jsonObj === undefined)) {
              _context2.next = 8;
              break;
            }
            error(messages.file.no_file_in_path);
            return _context2.abrupt("return");
          case 8:
            jsonObj = {
              data: JSON.parse(jsonObj)
            };
            // step: translate object
            _context2.next = 11;
            return objectTranslator(TranslationConfig, jsonObj, from, to);
          case 11:
            newJsonObj = _context2.sent;
            if (!(newJsonObj === undefined)) {
              _context2.next = 15;
              break;
            }
            error(messages.file.cannot_translate);
            return _context2.abrupt("return");
          case 15:
            // step: save translated data
            latestPath = objectPath.replace(/\\/g, '/');
            fileExt = getFileExt(latestPath);
            rootFolder = getRootFolder(latestPath);
            newJsonObj.forEach( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(element, index) {
                var currentJsonObj, fileName;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        currentJsonObj = element.data;
                        fileName = newFileName ? "/" + newFileName + "." + to[index] + "." + fileExt : "/" + to[index] + "." + fileExt;
                        _context.next = 4;
                        return saveFilePublic(rootFolder + fileName, currentJsonObj);
                      case 4:
                        success("For " + getLanguageKeyFromValue(to[index], TranslationConfig.TranslationModule.languages) + " --> " + fileName + " created.");
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return function (_x7, _x8) {
                return _ref.apply(this, arguments);
              };
            }());
          case 19:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fileTranslator.apply(this, arguments);
}
function getFileFromPath(_x6) {
  return _getFileFromPath.apply(this, arguments);
}
function _getFileFromPath() {
  _getFileFromPath = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(objectPath) {
    var jsonObj;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getFile(objectPath);
          case 2:
            jsonObj = _context3.sent;
            if (!(jsonObj === undefined)) {
              _context3.next = 8;
              break;
            }
            objectPath = __dirname + '\\' + objectPath;
            _context3.next = 7;
            return getFile(objectPath);
          case 7:
            jsonObj = _context3.sent;
          case 8:
            return _context3.abrupt("return", {
              jsonObj: jsonObj,
              objectPath: objectPath
            });
          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getFileFromPath.apply(this, arguments);
}
function getFileExt(latestPath) {
  // Check if source file has YAML extension and return the extension ("yml" or "yaml").
  var sourceFileMatchYamlExt = matchYamlExt(latestPath);
  // When source file has "yml" or "yaml" extension, use the same in output file path.
  // Otherwise, default "json" extension used.
  var fileExt = sourceFileMatchYamlExt || 'json';
  return fileExt;
}

function readProxyFile(_x) {
  return _readProxyFile.apply(this, arguments);
}
function _readProxyFile() {
  _readProxyFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file_path) {
    var confs, data, proxyList;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            confs = {
              checkerRX: /^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}:(\d){1,}$/
            };
            _context.next = 3;
            return promises.readFile(file_path, 'utf8');
          case 3:
            data = _context.sent;
            if (data) {
              _context.next = 7;
              break;
            }
            error('proxy file is empty!');
            return _context.abrupt("return");
          case 7:
            proxyList = data.split(/\r?\n/);
            proxyList = proxyList.filter(function (proxy_item) {
              return confs.checkerRX.test(proxy_item);
            });
            success("\n---------------- Proxy Mode ----------------\n");
            global.proxyList = proxyList;
          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _readProxyFile.apply(this, arguments);
}

var inquirer = /*#__PURE__*/require('inquirer');
function promptModuleKey() {
  return _promptModuleKey.apply(this, arguments);
}
function _promptModuleKey() {
  _promptModuleKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var module_key_choices, selectedModuleKey;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            module_key_choices = translationModuleKeys().map(function (key) {
              return {
                name: getTranslationModuleByKey(key).altName + (getTranslationModuleByKey(key).requirements ? ' | requirements: ' + getTranslationModuleByKey(key).requirements.join(' | ') : ''),
                value: key,
                "short": key
              };
            });
            selectedModuleKey = '';
            _context.next = 4;
            return inquirer.prompt([{
              type: 'list',
              name: 'moduleKey',
              message: messages.cli.select_module_message,
              pageSize: 20,
              choices: [].concat(module_key_choices, [new inquirer.Separator()])
            }]).then(function (answers) {
              selectedModuleKey = answers.moduleKey;
            });
          case 4:
            return _context.abrupt("return", selectedModuleKey);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _promptModuleKey.apply(this, arguments);
}
function promptFrom(_x) {
  return _promptFrom.apply(this, arguments);
}
function _promptFrom() {
  _promptFrom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(languages) {
    var fromLanguageKeys, answers;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            fromLanguageKeys = Object.keys(languages);
            _context2.next = 3;
            return inquirer.prompt([{
              type: 'list',
              name: 'from',
              message: messages.cli.from_message,
              pageSize: 20,
              choices: [].concat(fromLanguageKeys, [new inquirer.Separator()])
            }]);
          case 3:
            answers = _context2.sent;
            return _context2.abrupt("return", answers.from);
          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _promptFrom.apply(this, arguments);
}
function promptTo(_x2, _x3) {
  return _promptTo.apply(this, arguments);
}
function _promptTo() {
  _promptTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(languages, default_languages) {
    var toLanguageKeys, answers;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            toLanguageKeys = Object.keys(languages);
            toLanguageKeys = toLanguageKeys.filter(function (key) {
              return key !== "Automatic";
            });
            _context3.next = 4;
            return inquirer.prompt([{
              type: 'checkbox',
              name: 'to',
              pageSize: 20,
              message: messages.cli.to_message,
              choices: toLanguageKeys,
              "default": default_languages ? default_languages : []
            }]);
          case 4:
            answers = _context3.sent;
            return _context3.abrupt("return", answers.to);
          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _promptTo.apply(this, arguments);
}
function promptName() {
  return _promptName.apply(this, arguments);
}
function _promptName() {
  _promptName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var answers;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return inquirer.prompt([{
              type: 'string',
              name: 'name',
              message: messages.cli.new_file_name_message
            }]);
          case 2:
            answers = _context4.sent;
            return _context4.abrupt("return", answers.name);
          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _promptName.apply(this, arguments);
}
function promptFallback() {
  return _promptFallback.apply(this, arguments);
}
function _promptFallback() {
  _promptFallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var answers;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return inquirer.prompt([{
              type: 'string',
              name: 'fallback',
              message: messages.cli.fallback_message,
              "default": ''
            }]);
          case 2:
            answers = _context5.sent;
            if (!(answers.fallback === '')) {
              _context5.next = 5;
              break;
            }
            return _context5.abrupt("return", 'no');
          case 5:
            return _context5.abrupt("return", answers.fallback);
          case 6:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _promptFallback.apply(this, arguments);
}
function promptConcurrencyLimit() {
  return _promptConcurrencyLimit.apply(this, arguments);
}
function _promptConcurrencyLimit() {
  _promptConcurrencyLimit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    var answers;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return inquirer.prompt([{
              type: 'number',
              name: 'concurrencylimit',
              message: messages.cli.concurrency_limit_message,
              "default": ''
            }]);
          case 2:
            answers = _context6.sent;
            if (!(answers.concurrencylimit === '')) {
              _context6.next = 5;
              break;
            }
            return _context6.abrupt("return", default_concurrency_limit);
          case 5:
            return _context6.abrupt("return", answers.concurrencylimit);
          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _promptConcurrencyLimit.apply(this, arguments);
}

var program = /*#__PURE__*/new Command();
function initializeCli() {
  return _initializeCli.apply(this, arguments);
}
function _initializeCli() {
  _initializeCli = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            global.totalTranslation = 0;
            global.totalTranslated = 0;
            global.proxyIndex = 0;
            global.proxyList = [];
            program.version(current_version).addHelpText('beforeAll', messages.cli.welcome).description(messages.cli.description).usage(messages.cli.usage).addOption(new Option("-m, --module <Module>", messages.cli.module).choices(translationModuleKeys())).addOption(new Option("-f, --from <Language>", messages.cli.from)).addOption(new Option("-t, --to <Languages...>", messages.cli.to)).addOption(new Option("-n, --name <string>", messages.cli.new_file_name)).addOption(new Option("-fb, --fallback <string>", messages.cli.fallback).choices(Object.keys(fallbacks))).addOption(new Option("-cl, --concurrencylimit <number>", messages.cli.concurrency_limit)).addHelpText('after', "\n" + messages.cli.usage_with_proxy + "\n" + messages.cli.usage_by_ops).addHelpText('afterAll', supportedLanguagesUrl);
            program.showSuggestionAfterError();
            program.exitOverride();
            try {
              program.parse();
            } catch (err) {
              process.exit();
            }
            if (process.argv.slice(2).length) {
              _context.next = 11;
              break;
            }
            program.outputHelp();
            return _context.abrupt("return");
          case 11:
            /*
              If the user adds an option without a value or forgets the value of the option, the value of the next option is applied to the proxy file path.
              It is actually a problem in commander.js
              I've come to this temporary solution, which is if the proxy path does not end with .txt display error 'messages.cli.proxy_File_notValid_or_not_empty_options'
            */
            if (program.args[1] !== undefined && !program.args[1].includes('.txt')) {
              error(messages.cli.proxy_file_notValid_or_not_empty_options);
              process.exit(1);
            }
            translate();
          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _initializeCli.apply(this, arguments);
}
function translate() {
  return _translate.apply(this, arguments);
} // getting input from user
function _translate() {
  _translate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var commandArguments, commandOptions, file_path, objectPath, _yield$getFileFromPat, jsonObj, TranslationConfig, fromLanguageValue, toLanguageValues, fileNameValue, fallbackValue, concurrencyLimitValue, _setLoading, load, refreshInterval;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            commandArguments = program.args;
            commandOptions = program.opts();
            if (!(commandArguments[1] && typeof commandArguments[1] === 'string')) {
              _context2.next = 6;
              break;
            }
            file_path = commandArguments[1];
            _context2.next = 6;
            return readProxyFile(file_path);
          case 6:
            // no path condition
            objectPath = commandArguments[0];
            if (!(objectPath === undefined || objectPath === '')) {
              _context2.next = 11;
              break;
            }
            error(messages.file.no_path);
            info("([path] " + messages.cli.paths + ")");
            return _context2.abrupt("return");
          case 11:
            _context2.next = 13;
            return getFileFromPath(objectPath);
          case 13:
            _yield$getFileFromPat = _context2.sent;
            jsonObj = _yield$getFileFromPat.jsonObj;
            if (!(jsonObj === undefined)) {
              _context2.next = 18;
              break;
            }
            error(messages.file.no_file_in_path);
            return _context2.abrupt("return");
          case 18:
            _context2.next = 20;
            return translationConfig(commandOptions);
          case 20:
            TranslationConfig = _context2.sent;
            _context2.next = 23;
            return fromLanguage(commandOptions, TranslationConfig.TranslationModule);
          case 23:
            fromLanguageValue = _context2.sent;
            _context2.next = 26;
            return toLanguages(commandOptions, TranslationConfig.TranslationModule);
          case 26:
            toLanguageValues = _context2.sent;
            _context2.next = 29;
            return fileName(commandOptions);
          case 29:
            fileNameValue = _context2.sent;
            _context2.next = 32;
            return fallback(commandOptions);
          case 32:
            fallbackValue = _context2.sent;
            TranslationConfig.fallback = fallbackValue;
            // get concurrency limit
            _context2.next = 36;
            return concurrencyLimit(commandOptions);
          case 36:
            concurrencyLimitValue = _context2.sent;
            TranslationConfig.concurrencyLimit = concurrencyLimitValue;
            // set loading
            _setLoading = setLoading(), load = _setLoading.load, refreshInterval = _setLoading.refreshInterval;
            _context2.next = 41;
            return fileTranslator(TranslationConfig, objectPath, fromLanguageValue, toLanguageValues, fileNameValue);
          case 41:
            load.succeed("DONE! " + translationStatistic(global.totalTranslation, global.totalTranslation));
            clearInterval(refreshInterval);
            info(messages.cli.creation_done);
          case 44:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _translate.apply(this, arguments);
}
function translationConfig(_x) {
  return _translationConfig.apply(this, arguments);
}
function _translationConfig() {
  _translationConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(commandOptions) {
    var _commandOptions$modul;
    var moduleKey, TranslationModule, translationConfig;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            moduleKey = (_commandOptions$modul = commandOptions.module) != null ? _commandOptions$modul : undefined;
            if (!(moduleKey && translationModuleKeys().includes(moduleKey))) {
              _context3.next = 5;
              break;
            }
            // valid module key
            TranslationModule = getTranslationModuleByKey(moduleKey);
            _context3.next = 14;
            break;
          case 5:
            if (!moduleKey) {
              _context3.next = 10;
              break;
            }
            // invalid module key
            error("" + messages.cli.module_not_available);
            process.exit(1);
            _context3.next = 14;
            break;
          case 10:
            _context3.next = 12;
            return promptModuleKey();
          case 12:
            moduleKey = _context3.sent;
            TranslationModule = getTranslationModuleByKey(moduleKey);
          case 14:
            translationConfig = {
              moduleKey: moduleKey,
              TranslationModule: TranslationModule,
              concurrencyLimit: default_concurrency_limit,
              fallback: default_fallback
            };
            return _context3.abrupt("return", translationConfig);
          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _translationConfig.apply(this, arguments);
}
function fromLanguage(_x2, _x3) {
  return _fromLanguage.apply(this, arguments);
}
function _fromLanguage() {
  _fromLanguage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(commandOptions, TranslationModule) {
    var _commandOptions$from;
    var fromLanguageInput, fromLanguageValue, supportedLanguageValues, _fromLanguageInput;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            fromLanguageInput = (_commandOptions$from = commandOptions.from) != null ? _commandOptions$from : undefined;
            supportedLanguageValues = Object.values(TranslationModule.languages);
            if (fromLanguageInput) {
              _context4.next = 9;
              break;
            }
            _context4.next = 5;
            return promptFrom(TranslationModule.languages);
          case 5:
            _fromLanguageInput = _context4.sent;
            fromLanguageValue = TranslationModule.languages[_fromLanguageInput];
            _context4.next = 10;
            break;
          case 9:
            if (supportedLanguageValues.includes(fromLanguageInput)) {
              fromLanguageValue = fromLanguageInput;
            } else {
              error("[" + fromLanguageInput + "]: " + messages.cli.from_not_available);
              process.exit(1);
            }
          case 10:
            return _context4.abrupt("return", fromLanguageValue);
          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fromLanguage.apply(this, arguments);
}
function toLanguages(_x4, _x5) {
  return _toLanguages.apply(this, arguments);
}
function _toLanguages() {
  _toLanguages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(commandOptions, TranslationModule) {
    var _commandOptions$to;
    var toLanguageInputs, toLanguageValues, supportedLanguageValues, toLanguageKeys, _toLanguageKeys;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            toLanguageInputs = (_commandOptions$to = commandOptions.to) != null ? _commandOptions$to : undefined;
            supportedLanguageValues = Object.values(TranslationModule.languages);
            if (toLanguageInputs) {
              _context5.next = 15;
              break;
            }
            _context5.next = 5;
            return promptTo(TranslationModule.languages);
          case 5:
            toLanguageKeys = _context5.sent;
            toLanguageValues = toLanguageKeys.map(function (key) {
              return TranslationModule.languages[key];
            });
            // second chance to select languages
            if (!(toLanguageValues.length === 0 || toLanguageValues === undefined)) {
              _context5.next = 13;
              break;
            }
            warn(messages.cli.no_selected_language);
            _context5.next = 11;
            return promptTo(TranslationModule.languages);
          case 11:
            _toLanguageKeys = _context5.sent;
            toLanguageValues = _toLanguageKeys.map(function (key) {
              return TranslationModule.languages[key];
            });
          case 13:
            _context5.next = 16;
            break;
          case 15:
            toLanguageValues = toLanguageInputs.map(function (lang) {
              if (supportedLanguageValues.includes(lang)) {
                return lang;
              } else {
                error("[" + lang + "]: " + messages.cli.to_not_available);
                process.exit(1);
              }
            });
          case 16:
            return _context5.abrupt("return", toLanguageValues);
          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _toLanguages.apply(this, arguments);
}
function fileName(_x6) {
  return _fileName.apply(this, arguments);
}
function _fileName() {
  _fileName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(commandOptions) {
    var _commandOptions$name;
    var newFileName, name;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            newFileName = (_commandOptions$name = commandOptions.name) != null ? _commandOptions$name : undefined;
            if (newFileName) {
              _context6.next = 6;
              break;
            }
            _context6.next = 4;
            return promptName();
          case 4:
            name = _context6.sent;
            newFileName = name;
          case 6:
            return _context6.abrupt("return", newFileName);
          case 7:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _fileName.apply(this, arguments);
}
function fallback(_x7) {
  return _fallback.apply(this, arguments);
}
function _fallback() {
  _fallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(commandOptions) {
    var _commandOptions$fallb;
    var fallbackStr, fallback;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            fallbackStr = (_commandOptions$fallb = commandOptions.fallback) != null ? _commandOptions$fallb : undefined;
            fallback = false;
            if (fallbackStr) {
              _context7.next = 7;
              break;
            }
            _context7.next = 5;
            return promptFallback();
          case 5:
            fallbackStr = _context7.sent;
            if (!Object.keys(fallbacks).includes(fallbackStr)) {
              error("[" + fallbackStr + "]: " + messages.cli.fallback_not_available);
              process.exit(1);
            }
          case 7:
            if (fallbackStr === 'yes') {
              fallback = fallbacks.yes;
            } else {
              fallback = fallbacks.no;
            }
            return _context7.abrupt("return", fallback);
          case 9:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _fallback.apply(this, arguments);
}
function concurrencyLimit(_x8) {
  return _concurrencyLimit.apply(this, arguments);
}
function _concurrencyLimit() {
  _concurrencyLimit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(commandOptions) {
    var _commandOptions$concu;
    var concurrencyLimitInput, concurrencyLimit;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            concurrencyLimitInput = (_commandOptions$concu = commandOptions.concurrencylimit) != null ? _commandOptions$concu : undefined;
            if (concurrencyLimitInput) {
              _context8.next = 5;
              break;
            }
            _context8.next = 4;
            return promptConcurrencyLimit();
          case 4:
            concurrencyLimitInput = _context8.sent;
          case 5:
            concurrencyLimit = Number(concurrencyLimitInput);
            return _context8.abrupt("return", Number.isNaN(concurrencyLimit) ? default_concurrency_limit : Number(concurrencyLimit));
          case 7:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _concurrencyLimit.apply(this, arguments);
}
function setLoading() {
  var load = loading({
    text: "Translating. Please wait. " + translationStatistic(global.totalTranslated, global.totalTranslation),
    color: 'yellow',
    interval: 100,
    stream: process.stdout,
    frames: ['.', 'o', 'O', '°', 'O', 'o', '.']
  }).start();
  var refreshInterval = setInterval(function () {
    load.text = "Translating. Please wait. " + translationStatistic(global.totalTranslated, global.totalTranslation);
  }, 200);
  return {
    load: load,
    refreshInterval: refreshInterval
  };
}

// TODO: fix to get from user
function translateWord(_x, _x2, _x3) {
  return _translateWord.apply(this, arguments);
}
// TODO: fix to get from user
function _translateWord() {
  _translateWord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(word, from, to) {
    var config;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            config = {
              moduleKey: 'google',
              TranslationModule: TranslationModules['google'],
              concurrencyLimit: default_concurrency_limit,
              fallback: default_fallback
            };
            _context.next = 3;
            return plaintranslate(config, word, from, to, []);
          case 3:
            return _context.abrupt("return", _context.sent);
          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _translateWord.apply(this, arguments);
}
function translateObject(_x4, _x5, _x6) {
  return _translateObject.apply(this, arguments);
}
function _translateObject() {
  _translateObject = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(object, from, to) {
    var hard_copy, config;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            hard_copy = JSON.parse(JSON.stringify(object));
            config = {
              moduleKey: 'google',
              TranslationModule: TranslationModules['google'],
              concurrencyLimit: default_concurrency_limit,
              fallback: default_fallback
            };
            return _context2.abrupt("return", objectTranslator(config, hard_copy, from, to));
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _translateObject.apply(this, arguments);
}
function translateFile(_x7, _x8, _x9, _x10) {
  return _translateFile.apply(this, arguments);
}
function _translateFile() {
  _translateFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(objectPath, from, to, newFileName) {
    var config;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            config = {
              moduleKey: 'google',
              TranslationModule: TranslationModules['google'],
              concurrencyLimit: default_concurrency_limit,
              fallback: default_fallback
            };
            return _context3.abrupt("return", fileTranslator(config, objectPath, from, to, newFileName));
          case 2:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _translateFile.apply(this, arguments);
}
function runCli() {
  return _runCli.apply(this, arguments);
}
function _runCli() {
  _runCli = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            initializeCli();
          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _runCli.apply(this, arguments);
}

export { runCli, translateFile, translateObject, translateWord };
//# sourceMappingURL=json-translator.esm.js.map
